<script>
function buildSvg(){
  const svg=document.getElementById('buildingSvg');
  svg.innerHTML='';
  addDefs(svg);

  const scene=NS('g');
  scene.setAttribute('id','scene');
  svg.appendChild(scene);

  const W25=64, D25=64;      // 2.5 Zimmer
  const W15=W25, D15=D25/2;  // 1.5 Zimmer
  const H=26;
  const gapY=8;
  const floorGapZ=126;
  const originX=0;

  // For right→left numbering we already compute y from max index.
  const maxByLevel = (function(){
    const map={}; 
    DATA.forEach(u=>{
      const n=parseInt(String(u.id).split('.')[1],10)||0;
      map[u.level]=Math.max(map[u.level]||0,n);
    });
    return map;
  })();

  function yForUnit(level, subIndex, d){
    const max = maxByLevel[level]||subIndex;
    const posFromLeft = max - subIndex; // 0=leftmost
    return posFromLeft * (d + gapY);
  }

  // ********* NEW: stable draw order (fixes overlapping) *********
  // Draw floors back→front: 3,2,1; within a floor left→right: 14..1
  const drawList = [...DATA].sort((a,b)=>{
    if (a.level !== b.level) return b.level - a.level; // 3 → 2 → 1
    const sa = parseInt(String(a.id).split('.')[1],10)||0;
    const sb = parseInt(String(b.id).split('.')[1],10)||0;
    return sb - sa; // 14 .. 1 (so 1 is drawn last = on top)
  });

  drawList.forEach(u=>{
    const is25 = (u.rooms===2.5);
    const w = is25 ? W25 : W15;
    const d = is25 ? D25 : D15;

    const z=(u.level-1)*(H + floorGapZ);
    const sub = parseInt(String(u.id).split('.')[1],10)||0;
    const y = yForUnit(u.level, sub, d);
    const x = originX;

    const colors = safeColors(u.status);
    const block=makeIsoBlock(x,y,z,w,d,H,colors,u.id);
    scene.appendChild(block);

    /* ---------- FLOOR 1 (2.5er) ---------- */
    if(u.level===1 && is25){
      const bw=35, bh=4, segGap=4; const segD=(d-segGap)/2;
      const outline=()=>({top:'none',front:'none',side:'none'});

      // Front: upper outline + lower filled
      const left1  = makeIsoPrismRaw(x-bw-1, y,            z, bw, segD, bh, outline(), 'balcony', u.id);
      const left2  = makeIsoPrismRaw(x-bw-1, y+segD+segGap,z, bw, segD, bh, colors,   'balcony', u.id);

      // Rear default: upper filled + lower outline
      let right1Colors = colors;
      let right2Colors = outline();
      let right2Extra=null;

      // 1.2 rear = stairs + lift (like 3.2)
      if(u.id==="1.2"){
        right1Colors = {top:STAIRS_FILL,front:STAIRS_FILL,side:STAIRS_FILL};
        right2Colors = {top:FILL_DARK15,front:FILL_DARK15,side:FILL_DARK15};
        right2Extra  = (g)=>addInsetOnTop(g, x+w+1, y+segD+segGap, z, bw, segD, 6, 'rgba(255,255,255,0.65)', 'rgba(0,0,0,0.45)');
      }
      // 1.7 rear lower = stairs
      if(u.id==="1.7"){ right2Colors = {top:STAIRS_FILL,front:STAIRS_FILL,side:STAIRS_FILL}; }

      const right1 = makeIsoPrismRaw(x+w+1, y,            z, bw, segD, bh, right1Colors, 'balcony', u.id);
      const right2 = makeIsoPrismRaw(x+w+1, y+segD+segGap,z, bw, segD, bh, right2Colors, 'balcony', u.id);
      if(right2Extra) right2Extra(right2);

      [left1,left2,right1,right2].forEach(p=>scene.insertBefore(p, block));
    }

    /* ---------- FLOOR 2 (1.5er) ---------- */
    if(u.level===2){
      const bw=35, bh=4;
      // Full-length default balconies
      const frontFull = makeIsoPrismRaw(x-bw-1, y, z, bw, d, bh, colors, 'balcony', u.id);  // front
      const rearFull  = makeIsoPrismRaw(x+w+1, y, z, bw, d, bh, colors, 'balcony', u.id);   // rear

      const keepRear  = (sub % 2 === 1); // 2.1 rear, 2.3 rear, ...
      const keepFront = (sub % 2 === 0); // 2.2 front, 2.4 front, ...

      // ********* NEW: overrides moved to 2.12 / 2.13 (2.14 remains) *********
      if(u.id==="2.12" || u.id==="2.14"){
        const rearStairs = makeIsoPrismRaw(x+w+1, y, z, bw, d, bh,
          {top:STAIRS_FILL,front:STAIRS_FILL,side:STAIRS_FILL}, 'balcony', u.id);
        scene.insertBefore(rearStairs, block);
      } else if(u.id==="2.13"){
        const rearLift = makeIsoPrismRaw(x+w+1, y, z, bw, d, bh,
          {top:FILL_DARK15,front:FILL_DARK15,side:FILL_DARK15}, 'balcony', u.id);
        addInsetOnTop(rearLift, x+w+1, y, z, bw, d, 8, 'rgba(255,255,255,0.65)', 'rgba(0,0,0,0.45)');
        scene.insertBefore(rearLift, block);
      } else {
        if(keepFront) scene.insertBefore(frontFull, block);
        if(keepRear)  scene.insertBefore(rearFull,  block);
      }
    }

    /* ---------- FLOOR 3 (2.5er) ---------- */
    if(u.level===3 && is25){
      const bw=35, bh=4, segGap=4; const segD=(d-segGap)/2;

      if(u.id==="3.2"){
        const rearLeft  = makeIsoPrismRaw(x+w+1, y,            z, bw, segD, bh,
          {top:STAIRS_FILL,front:STAIRS_FILL,side:STAIRS_FILL}, 'balcony', u.id);
        const rearRight = makeIsoPrismRaw(x+w+1, y+segD+segGap,z, bw, segD, bh,
          {top:FILL_DARK15,front:FILL_DARK15,side:FILL_DARK15}, 'balcony', u.id);
        addInsetOnTop(rearRight, x+w+1, y+segD+segGap, z, bw, segD, 6, 'rgba(255,255,255,0.65)', 'rgba(0,0,0,0.45)');
        scene.insertBefore(rearLeft,  block);
        scene.insertBefore(rearRight, block);

        const left2 = makeIsoPrismRaw(x-bw-1, y+segD+segGap, z, bw, segD, bh, colors, 'balcony', u.id);
        scene.insertBefore(left2, block);
      }else{
        const left2 = makeIsoPrismRaw(x-bw-1, y+segD+segGap, z, bw, segD, bh, colors, 'balcony', u.id);
        const right1= makeIsoPrismRaw(x+w+1,  y,           z, bw, segD, bh, colors, 'balcony', u.id);
        [left2,right1].forEach(p=>scene.insertBefore(p, block));
      }
    }
  });

  // Fit to viewBox
  const vb=svg.viewBox.baseVal; const margin=40;
  const bbox=document.getElementById('scene').getBBox();
  if(bbox.width>0 && bbox.height>0){
    const scale=Math.min((vb.width-2*margin)/bbox.width,(vb.height-2*margin)/bbox.height);
    const tx=(vb.width - bbox.width*scale)/2 - bbox.x*scale;
    const ty=(vb.height - bbox.height*scale)/2 - bbox.y*scale;
    document.getElementById('scene').setAttribute('transform',`translate(${tx},${ty}) scale(${scale})`);
  }
}
</script>
