<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Wohnungen Am Zug</title>
  <style>
    body{margin:0;font-family:sans-serif;background:#ffffff;color:#233441}
    .wrap{max-width:1400px;margin:22px auto;padding:12px}
    .panel{background:#f1f3f5;border-radius:14px;box-shadow:0 6px 20px rgba(0,0,0,.08);padding:18px 22px}
    .controls{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-bottom:16px}
    .field label{display:block;font-size:12px;color:#6b7b86;margin-bottom:4px}
    select{width:100%;padding:6px 8px;border-radius:6px;border:1px solid #cfd7dd}
    .grid{display:grid;grid-template-columns:1fr 2fr;gap:18px;align-items:start}
    table{width:100%;border-collapse:collapse;background:#fff;border-radius:12px;overflow:hidden}
    thead{background:#d2bd76;color:#000}
    th,td{padding:8px 10px;font-size:14px;border-bottom:1px solid #e0e6eb;text-align:left}
    tr:hover, tr.active{background:#f8fbfd}
    .map-container{background:#fff;border-radius:12px;border:1px solid #dfe6eb;padding:10px;display:flex;align-items:center;justify-content:center;height:100%}
    svg{width:100%;height:100%}
    .legend{display:flex;gap:14px;justify-content:flex-end;margin-top:10px;font-size:13px;color:#6b7b86}
    .legend .sq{width:12px;height:12px;border-radius:2px}
    .sq.ok{background:#5BBE7C}.sq.warn{background:#F5B942}.sq.no{background:#E17575}
    .dot{display:inline-block;width:10px;height:10px;border-radius:50%}
    .dot.available{background:#5BBE7C}
    .dot.reserved{background:#F5B942}
    .dot.rented{background:#E17575}

    .unit-block{transition:filter .18s ease, transform .18s ease; cursor:pointer}
    .unit-block.highlight{filter:saturate(1.8) brightness(1.06); transform:translateY(-2px)}
    .row-highlight{background:#fff7d6 !important; box-shadow:inset 0 0 0 2px #f5b94240}
    .row-flash{animation:flash 1.2s ease}
    @keyframes flash{0%{background:#fff3c4} 100%{background:transparent}}

    /* Balcony outlines kept */
    .balcony polygon{stroke:rgba(0,0,0,0.1); stroke-width:2}
    .balcony.highlight polygon{filter:saturate(1.8) brightness(1.06)}
  </style>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <h1>Wohnungen Am Zug</h1>
    <div class="controls">
      <div class="field"><label>Etage</label><select id="floorSel"></select></div>
      <div class="field"><label>Status</label><select id="statusSel">
        <option value="all">Alle</option>
        <option value="available">Verfügbar</option>
        <option value="reserved">Reserviert</option>
        <option value="rented">Vermietet</option>
      </select></div>
      <div class="field"><label>Zimmer</label><select id="roomsSel"></select></div>
    </div>
    <div class="grid">
      <div>
        <table>
          <thead>
            <tr>
              <th>Nr.</th>
              <th>Zimmer</th>
              <th>Etage</th>
              <th>m²</th>
              <th>Status</th>
              <th>Factsheet</th>
            </tr>
          </thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>
      <div>
        <div class="map-container">
          <svg id="buildingSvg" viewBox="0 0 1600 900"></svg>
        </div>
        <div class="legend"><span class="sq ok"></span> Verfügbar <span class="sq warn"></span> Reserviert <span class="sq no"></span> Vermietet</div>
      </div>
    </div>
  </div>
</div>

<script>
/* ======== SHEET CSV ======== */
const SHEET_CSV = "https://docs.google.com/spreadsheets/d/1-oeqRNM-CxGaILY7FNWaNMgC9ccBWDZDwU5l0Eic0pk/export?format=csv&gid=0";

/* ======== NORMALIZATION ======== */
function normStatus(v){
  const t = String(v||"").trim().toLowerCase();
  if(['available','verfügbar','verfuegbar','frei'].includes(t)) return 'available';
  if(['reserved','reserviert'].includes(t)) return 'reserved';
  if(['rented','vermietet','belegt'].includes(t)) return 'rented';
  return 'available';
}
function num(x){ const n = Number(String(x||"").replace(',','.')); return isNaN(n) ? null : n; }

/* ======== PARSE CSV (supports new key/level/unit AND legacy id) ======== */
function parseCsv(text){
  const lines = text.trim().split(/\r?\n/);
  if(!lines.length) return [];
  const headers = lines[0].split(",").map(h=>h.trim().toLowerCase());

  return lines.slice(1).filter(Boolean).map(row=>{
    const vals=row.split(",").map(v=>(v||"").trim());
    const o={}; headers.forEach((h,i)=>o[h]=vals[i]||"");

    const level = num(o.level);
    let unit    = num(o.unit);
    let rooms   = num(o.rooms);
    const m2    = num(o.m2);
    const factsheet = o.factsheet || "";

    // If unit is missing but legacy id exists, derive from it (best-effort)
    if(!unit && o.id){
      const m = String(o.id).trim().match(/^(\d+)\.(\d+)$/);
      if(m){ unit = num(m[2]); }
    }

    // Derive display id from level+unit
    const displayId = (level && unit) ? `${level}.${unit}` : (o.id || "");

    // Internal stable key: prefer provided key; else generate from level+unit
    const key = String(o.key || (level && unit ? `L${level}-U${unit}` : displayId)).trim();

    return {
      key,                // internal immutable
      id: displayId,      // shown in table
      level,
      unit,
      rooms,
      m2,
      status: normStatus(o.status),
      factsheet
    };
  }).filter(u=>u.key && u.level && u.unit && u.rooms);
}

/* ======== COLORS ======== */
const statusColors={
  available:{top:'#dff2e7',front:'#cce6d6',side:'#c2dfcf'},
  reserved:{top:'#fff3db',front:'#f0e1bf',side:'#e8d7ad'},
  rented:{top:'#f9e0e0',front:'#eac9c9',side:'#e2bcbc'}
};
function col(status){ return statusColors[normStatus(status)] || statusColors.available; }
const FILL_DARK15 = 'rgba(0,0,0,0.15)';           // lift
const STAIRS_FILL = 'url(#stairsPattern)';         // WHITE stairs pattern

/* ======== TABLE & FILTERS ======== */
let DATA = []; // will be sheet-driven

function renderTable(list){
  const tbody=document.getElementById('tbody');
  tbody.innerHTML=list.map(d=>`
    <tr data-key="${d.key}">
      <td>${d.id}</td>
      <td>${d.rooms}</td>
      <td>${d.level}</td>
      <td>${d.m2 ?? ""}</td>
      <td><span class='dot ${normStatus(d.status)}' title='${normStatus(d.status)}'></span></td>
      <td>${d.factsheet ? `<a href="${d.factsheet}" target="_blank" rel="noopener">Factsheet</a>` : '–'}</td>
    </tr>`).join('');
  tbody.querySelectorAll('tr').forEach(tr=>{
    const key=tr.getAttribute('data-key');
    tr.addEventListener('mouseenter',()=>highlight(key,true));
    tr.addEventListener('mouseleave',()=>highlight(key,false));
    tr.addEventListener('click',()=>openFactsheet(key));
  });
}
function applyFilters(){
  const fFloor=document.getElementById('floorSel').value;
  const fStatus=document.getElementById('statusSel').value;
  const fRooms=document.getElementById('roomsSel').value;
  const list=DATA.filter(d=>
    (fFloor==='all'||String(d.level)===String(fFloor)) &&
    (fStatus==='all'||normStatus(d.status)===fStatus) &&
    (fRooms==='all'||String(d.rooms)===String(fRooms))
  );
  renderTable(list);
}
function populateSelects(){
  const floors=[...new Set(DATA.map(d=>d.level))].sort((a,b)=>a-b);
  const rooms=[...new Set(DATA.map(d=>d.rooms))].sort((a,b)=>a-b);
  document.getElementById('floorSel').innerHTML =
    '<option value="all">Alle</option>' + floors.map(f=>`<option value="${f}">${f}</option>`).join('');
  document.getElementById('roomsSel').innerHTML =
    '<option value="all">Alle</option>' + rooms.map(r=>`<option value="${r}">${r}</option>`).join('');
}

/* ======== ISOMETRIC CORE ======== */
const COS=Math.cos(Math.PI/6), SIN=Math.sin(Math.PI/6);
function isoX(x,y,z){return (x + y)*COS;}
function isoY(x,y,z){return (y - x)*SIN - z;}
function NS(tag){ return document.createElementNS('http://www.w3.org/2000/svg',tag); }
function poly(pts,fill){ const p=NS('polygon'); p.setAttribute('points', pts.map(([X,Y,Z])=>`${isoX(X,Y,Z)} ${isoY(X,Y,Z)}`).join(' ')); p.setAttribute('fill', fill==='none'?'none':fill); return p; }
function makeIsoBlock(x,y,z,w,d,h,colors,key){
  const g=NS('g'); g.setAttribute('class','unit-block'); g.setAttribute('data-key',key);
  const pTop   = poly([[x,y,z],[x+w,y,z],[x+w,y+d,z],[x,y,d+z]], colors.top);
  const pFront = poly([[x,y,z],[x+w,y,z],[x+w,y,z+h],[x,y,z+h]], colors.front);
  const pSide  = poly([[x+w,y,z],[x+w,y+d,z],[x+w,y+d,z+h],[x+w,y,z+h]], colors.side);
  [pTop,pFront,pSide].forEach(p=>g.appendChild(p)); return g;
}
function makeIsoPrismRaw(x,y,z,w,d,h,colors, cssClass, key){
  const g=NS('g'); if(cssClass) g.setAttribute('class',cssClass); if(key) g.setAttribute('data-key',key);
  const pTop   = poly([[x,y,z],[x+w,y,z],[x+w,y+d,z],[x,y,d+z]], colors.top||'none');
  const pFront = poly([[x,y,z],[x+w,y,z],[x+w,y,z+h],[x,y,z+h]], colors.front||'none');
  const pSide  = poly([[x+w,y,z],[x+w,y+d,z],[x+w,y+d,z+h],[x+w,y,z+h]], colors.side||'none');
  [pTop,pFront,pSide].forEach(p=>g.appendChild(p)); return g;
}
function addInsetOnTop(g, x, y, z, w, d, insetPx, fill, stroke){
  const top = [[x,y,z],[x+w,y,z],[x+w,y+d,z],[x,y+d,z]].map(([X,Y,Z])=>[isoX(X,Y,Z),isoY(X,Y,Z)]);
  const cx = top.reduce((s,p)=>s+p[0],0)/4, cy = top.reduce((s,p)=>s+p[1],0)/4;
  const pts = top.map(([X,Y])=>{const vx=X-cx,vy=Y-cy,len=Math.hypot(vx,vy)||1,k=(len-insetPx)/len;return [cx+vx*k,cy+vy*k];});
  const p=NS('polygon'); p.setAttribute('points', pts.map(a=>a.join(' ')).join(' '));
  if(fill) p.setAttribute('fill',fill); else p.setAttribute('fill','none');
  if(stroke){ p.setAttribute('stroke',stroke); p.setAttribute('stroke-width','2'); }
  g.appendChild(p);
}
function addDefs(svg){
  // WHITE stairs background, lines at 30°
  const defs=NS('defs');
  const pat=NS('pattern');
  pat.setAttribute('id','stairsPattern');
  pat.setAttribute('patternUnits','userSpaceOnUse');
  pat.setAttribute('width','8'); pat.setAttribute('height','8');
  pat.setAttribute('patternTransform','rotate(30)');
  const bg=NS('rect'); bg.setAttribute('x','0'); bg.setAttribute('y','0'); bg.setAttribute('width','8'); bg.setAttribute('height','8'); bg.setAttribute('fill','#ffffff'); pat.appendChild(bg);
  const lines=NS('path'); lines.setAttribute('d','M0,0 L0,8 M4,0 L4,8'); lines.setAttribute('stroke','rgba(0,0,0,0.55)'); lines.setAttribute('stroke-width','1.4'); pat.appendChild(lines);
  defs.appendChild(pat); svg.appendChild(defs);
}
function addFullLengthBalconies(x,y,z,w,d,status,key){
  const bw=35, bh=4;
  const colors=col(status);
  const leftFull  = makeIsoPrismRaw(x-bw-1, y, z, bw, d, bh, colors, 'balcony', key); // FRONT
  const rightFull = makeIsoPrismRaw(x+w+1, y, z, bw, d, bh, colors, 'balcony', key); // REAR
  return [leftFull, rightFull];
}

/* ======== BUILD SVG (ordering by level + unit) ======== */
function buildSvg(){
  const svg=document.getElementById('buildingSvg');
  svg.innerHTML='';
  addDefs(svg);
  const scene=NS('g'); scene.setAttribute('id','scene'); svg.appendChild(scene);

  const W25=64, D25=64;      // 2.5 Zimmer
  const W15=W25, D15=D25/2;  // 1.5 Zimmer
  const H=26; const gapY=8; const floorGapZ=126;
  const originX=0, originY=0;

  [1,2,3].forEach(level=>{
    const units=DATA.filter(d=>d.level===level).sort((a,b)=>a.unit-b.unit); // 1..N right->left
    const x=originX;
    const z=(level-1)*(H + floorGapZ);
    let y=originY;

    units.forEach((u,idx)=>{
      const is25 = (u.rooms===2.5);
      const w = is25 ? W25 : W15;
      const d = is25 ? D25 : D15;

      const block=makeIsoBlock(x,y,z,w,d,H,col(u.status),u.key);
      scene.appendChild(block);

      if(level===1 && is25){
        const bw=35, bh=4, gap=4; const segD=(d-gap)/2;
        const colors=col(u.status);
        const outline=()=>({top:'none',front:'none',side:'none'});
        const left1 = makeIsoPrismRaw(x-bw-1, y, z, bw, segD, bh, outline(), 'balcony', u.key);
        const left2 = makeIsoPrismRaw(x-bw-1, y+segD+gap, z, bw, segD, bh, colors,   'balcony', u.key);

        let right1Colors = colors;
        let right2Colors = outline();
        let right2Extra  = null;

        if(u.id==="1.2"){
          right1Colors = {top:STAIRS_FILL,front:STAIRS_FILL,side:STAIRS_FILL};
          right2Colors = {top:FILL_DARK15,front:FILL_DARK15,side:FILL_DARK15};
          right2Extra  = (g)=>addInsetOnTop(g, x+w+1, y+segD+gap, z, bw, segD, 6, 'rgba(255,255,255,0.65)', 'rgba(0,0,0,0.45)');
        }
        if(u.id==="1.7"){
          right2Colors = {top:STAIRS_FILL,front:STAIRS_FILL,side:STAIRS_FILL};
        }

        const right1= makeIsoPrismRaw(x+w+1,  y,            z, bw, segD, bh, right1Colors, 'balcony', u.key);
        const right2= makeIsoPrismRaw(x+w+1,  y+segD+gap,   z, bw, segD, bh, right2Colors, 'balcony', u.key);
        if(right2Extra) right2Extra(right2);
        [left1,left2,right1,right2].forEach(p=>scene.insertBefore(p, block));
      }

      if(level===2){
        const [frontBalcony, rearBalcony] = addFullLengthBalconies(x,y,z,w,d,u.status,u.key);
        const keepFront = (idx % 2 === 1); // 2.2, 2.4, ...
        const keepRear  = (idx % 2 === 0); // 2.1, 2.3, ...
        if(keepFront) scene.insertBefore(frontBalcony, block);
        if(keepRear)  scene.insertBefore(rearBalcony,  block);
      }

      if(level===3 && is25){
        const bw=35, bh=4, gap=4; const segD=(d-gap)/2;
        const colors=col(u.status);
        if(u.id==="3.2"){
          const rearLeft  = makeIsoPrismRaw(x+w+1, y, z, bw, segD, bh,
            {top:STAIRS_FILL,front:STAIRS_FILL,side:STAIRS_FILL}, 'balcony', u.key);
          const rearRight = makeIsoPrismRaw(x+w+1, y+segD+gap, z, bw, segD, bh,
            {top:FILL_DARK15,front:FILL_DARK15,side:FILL_DARK15}, 'balcony', u.key);
          addInsetOnTop(rearRight, x+w+1, y+segD+gap, z, bw, segD, 6, 'rgba(255,255,255,0.65)', 'rgba(0,0,0,0.45)');
          scene.insertBefore(rearLeft,  block);
          scene.insertBefore(rearRight, block);
          const left2 = makeIsoPrismRaw(x-bw-1, y+segD+gap, z, bw, segD, bh, colors, 'balcony', u.key);
          scene.insertBefore(left2, block);
        }else{
          const left2 = makeIsoPrismRaw(x-bw-1, y+segD+gap, z, bw, segD, bh, colors, 'balcony', u.key);
          const right1= makeIsoPrismRaw(x+w+1,  y,           z, bw, segD, bh, colors, 'balcony', u.key);
          [left2,right1].forEach(p=>scene.insertBefore(p, block));
        }
      }

      y += d + gapY; // advance along the row
    });
  });

  // Fit to viewBox
  const vb=svg.viewBox.baseVal; const margin=40;
  const bbox=document.getElementById('scene').getBBox();
  const scale=Math.min((vb.width-2*margin)/bbox.width, (vb.height-2*margin)/bbox.height);
  const tx=(vb.width - bbox.width*scale)/2 - bbox.x*scale;
  const ty=(vb.height - bbox.height*scale)/2 - bbox.y*scale;
  document.getElementById('scene').setAttribute('transform',`translate(${tx},${ty}) scale(${scale})`);
}

/* ======== INTERACTIVITY (key-based) ======== */
function setSvgInteractivity(){
  const svg=document.getElementById('buildingSvg');
  svg.querySelectorAll('[data-key]').forEach(el=>{
    const key=el.getAttribute('data-key');
    el.style.cursor='pointer';
    el.addEventListener('mouseenter',()=>highlight(key,true));
    el.addEventListener('mouseleave',()=>highlight(key,false));
    el.addEventListener('click',()=>openFactsheet(key));
  });
}
function highlight(key,on){
  document.querySelectorAll(`#buildingSvg [data-key="${key}"]`).forEach(el=>{
    if(on) el.classList.add('highlight'); else el.classList.remove('highlight');
  });
  const tr=document.querySelector(`#tbody tr[data-key="${key}"]`);
  if(tr){ if(on) tr.classList.add('row-highlight'); else tr.classList.remove('row-highlight'); }
}
function openFactsheet(key){
  const unit = DATA.find(d=>d.key===key);
  if(unit){
    const tr=document.querySelector(`#tbody tr[data-key="${key}"]`);
    if(tr){ tr.scrollIntoView({behavior:'smooth', block:'center'}); tr.classList.add('row-flash'); setTimeout(()=>tr.classList.remove('row-flash'), 1200); }
    if(unit.factsheet){ window.open(unit.factsheet,'_blank','noopener'); }
  }
}

/* ======== LOAD FROM SHEET, THEN RENDER ======== */
async function init(){
  try{
    const res = await fetch(SHEET_CSV + "&_cb=" + Date.now(), { cache: "no-store" });
    const txt = await res.text();
    const rows = parseCsv(txt);
    if(rows.length) DATA = rows;
  }catch(e){
    console.warn("Sheet error; nothing drawn because we’re now sheet-driven. Check CSV/permissions.", e);
    DATA = []; // no fallback here to avoid mixing old & new schemas
  }
  // Populate filters from DATA
  if(!DATA.length){ return; }
  const floors=[...new Set(DATA.map(d=>d.level))].sort((a,b)=>a-b);
  const rooms=[...new Set(DATA.map(d=>d.rooms))].sort((a,b)=>a-b);
  document.getElementById('floorSel').innerHTML =
    '<option value="all">Alle</option>' + floors.map(f=>`<option value="${f}">${f}</option>`).join('');
  document.getElementById('roomsSel').innerHTML =
    '<option value="all">Alle</option>' + rooms.map(r=>`<option value="${r}">${r}</option>`).join('');

  applyFilters();
  buildSvg();
  setSvgInteractivity();
}

document.getElementById('statusSel').addEventListener('change',()=>{applyFilters(); buildSvg(); setSvgInteractivity();});
document.getElementById('floorSel').addEventListener('change',()=>{applyFilters(); buildSvg(); setSvgInteractivity();});
document.getElementById('roomsSel').addEventListener('change',()=>{applyFilters(); buildSvg(); setSvgInteractivity();});

init();
</script>
</body>
</html>
